slug: terraform-build-your-own-provider
id: h1tpybfmtmve
type: track
title: Build Your Own Terraform Provider
teaser: Learn how to create your own Terraform Provider to perform CRUD operations.
description: |-
  In this track, you will create a Terraform provider to interact with a fictional coffee-shop application, HashiCups.
  In the process, you will learn how providers map target APIs to Terraform in order to create, read, update, and delete
  resources.
icon: https://storage.googleapis.com/instruqt-frontend/assets/hashicorp/tracks/terraform.png
tags:
- terraform
owner: hashicorp
developers:
- neil@hashicorp.com
private: true
published: false
challenges:
- slug: setup-and-implement-read
  id: pxpflxfcohzc
  type: challenge
  title: Setup and Implement Read
  teaser: In this challenge you will learn to implement a read on a public endpoint
    for a Terraform Provider.
  assignment: |-
    *Set up your development environment*

    The Terraform HashiCups Provider repository has been cloned for you. It will serve as the boilerplate for your
    provider workspace. Change into the cloned repository.

    The HashiCups provider requires an instance of HashiCups. This has been started for you using `docker-compose` and
    the service is run on port `:19090`. Confirm the service is running.

    ```
    curl localhost:19090/health
    ```

    *Explore your development environment*


    Run the `go mod init` command to define this directory as the root of a module. Then, run `go mod vendor` to
    create a `vendor` directory that contains all the provider's dependencies.

    ```
    cd /root/github.com/hashicorp/terraform-provider-hashicups
    go mod init terraform-provider-hashicups
    go mod vendor
    ```

    Next, build the provider using the Makefile.

    ```
    make build
    ```

    This runs the `go build -o terraform-provider-hashicups` command. Terraform searches for plugins in the format of
    `terraform-<TYPE>-<NAME>`. In the case above, the plugin is of type "provider" and of name "hashicups".

    To verify things are working correctly, execute the recently created binary.

    ```
    ./terraform-provider-hashicups
    ```

    You should see output like the below.

    ```
    This binary is a plugin. These are not meant to be executed directly.
    Please execute the program that consumes these plugins, which will
    load any plugins automatically
    ```

    *Define the coffees data source*

    Now that you have created the provider, add the coffees data resource. The coffees data source will pull information
    on all coffees served by HashiCups.

    Create a new file named `data_source_coffee.go` in the `hashicups` directory and add the following code snippet. As a
    general convention, Terraform providers put each data source in their own file, named after the resource, prefixed
    with data_source_.

    The libraries imported here will be used in `dataSourceCoffeesRead`.

    ```
    package hashicups

    import (
      "context"
      "encoding/json"
      "fmt"
      "net/http"
      "strconv"
      "time"

      "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
      "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
    )

    func dataSourceCoffees() *schema.Resource {
      return &schema.Resource{
        ReadContext: dataSourceCoffeesRead,
        Schema: map[string]*schema.Schema{},
      }
    }
    ```

    *Define the coffees schema*

    ```
    curl localhost:19090/coffees
    ```

    Since the response returns a list of coffees, the coffees schema should reflect that. Update your coffees data
    source's schema with the following code snippet.

    ```
    Schema: map[string]*schema.Schema{
      "coffees": &schema.Schema{
        Type:     schema.TypeList,
        Computed: true,
        Elem: &schema.Resource{
          Schema: map[string]*schema.Schema{
            "id": &schema.Schema{
              Type:     schema.TypeInt,
              Computed: true,
            },
            "name": &schema.Schema{
              Type:     schema.TypeString,
              Computed: true,
            },
            "teaser": &schema.Schema{
              Type:     schema.TypeString,
              Computed: true,
            },
            "description": &schema.Schema{
              Type:     schema.TypeString,
              Computed: true,
            },
            "price": &schema.Schema{
              Type:     schema.TypeInt,
              Computed: true,
            },
            "image": &schema.Schema{
              Type:     schema.TypeString,
              Computed: true,
            },
            "ingredients": &schema.Schema{
              Type:     schema.TypeList,
              Computed: true,
              Elem: &schema.Resource{
                Schema: map[string]*schema.Schema{
                  "ingredient_id": &schema.Schema{
                    Type:     schema.TypeInt,
                    Computed: true,
                  },
                },
              },
            },
          },
        },
      },
    },
    ```

    Format your code.

    ```
    go fmt ./...
    ```

    Notice that the coffees schema is a `schema.TypeList` of coffee (`schema.Resource`).

    The coffee resource's properties should map to their respective values in the JSON response. In the above example
    response:

    - The coffee's `id` is `1`, a `schema.TypeInt`.
    - The coffee's `name` is `"Packer Spiced Latte"`, a `schema.TypeString`.
    - The coffee ingredients is an array of ingredient objects, a `schema.TypeList` with elements `map[string]*schema.Schema{}`.

    You can use various [schema types](https://www.terraform.io/docs/extend/schemas/schema-types.html) to define complex
    data models. You will implement a complex read in the later challenges.

    *Implement read*

    Now that you defined the coffees schema, you can implement the `dataSourceCoffeesRead` function.

    Add the following read function to your `hashicups/data_source_coffee.go` file.

    ```
    func dataSourceCoffeesRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
      client := &http.Client{Timeout: 10 * time.Second}

      // Warning or errors can be collected in a slice type
      var diags diag.Diagnostics

      req, err := http.NewRequest("GET", fmt.Sprintf("%s/coffees", "http://localhost:19090"), nil)
      if err != nil {
        return diag.FromErr(err)
      }

      r, err := client.Do(req)
      if err != nil {
        return diag.FromErr(err)
      }
      defer r.Body.Close()

      coffees := make([]map[string]interface{}, 0)
      err = json.NewDecoder(r.Body).Decode(&coffees)
      if err != nil {
        return diag.FromErr(err)
      }

      if err := d.Set("coffees", coffees); err != nil {
        return diag.FromErr(err)
      }

      // always run
      d.SetId(strconv.FormatInt(time.Now().Unix(), 10))

      return diags
    }
    ```

    Format your code.

    ```
    go fmt ./...
    ```

    This function creates a new GET request to `localhost:19090/coffees`. Then, it decodes the response into a
    `[]map[string]interface{}`. The `d.Set("coffees", coffees)` function sets the response body (list of coffees
    object) to Terraform coffees data source, assigning each value to its respective schema position. Finally, it uses
    `SetID` to set the resource ID.

    Notice that this function returns a diag.Diagnostics type, which can return multiple errors and warnings to
    Terraform, giving users more robust error and warning messages. You can use the `diag.FromErr()` helper function to
    convert a Go error to a `diag.Diagnostics type`. You will implement this in a later challenge.


    _Tip: This function doesn't use an API client library to explicitly show the steps involved. The HashiCups client
    library is used to abstract CRUD functionality in other tutorials._

    The existence of a non-blank ID tells Terraform that a resource was created. This ID can be any string value, but
    should be a value that Terraform can use to read the resource again. Since this data resource doesn't have a unique
    ID, you set the ID to the current UNIX time, which will force this resource to refresh during every Terraform apply.

    When you create something in Terraform but delete it manually, Terraform should gracefully handle it. If the API
    returns an error when the resource doesn't exist, the read function should check to see if the resource is
    available first. If the resource isn't available, the function should set the ID to an empty string so Terraform
    "destroys" the resource in state. The following code snippet is an example of how this can be implemented; you do
    not need to add this to your configuration for this tutorial.

    ```
    if resourceDoesntExist {
      d.SetID("")
      return
    }
    ```

    *Add a coffees data source to provider*

    Now that you've defined your data source, you can add it to your provider.

    In your `hashicups/provider.go` file, add the coffees data source to the `DataSourcesMap`. The `DataSourcesMap`
    attribute takes a map of the data source name, `hashicups_coffees`, and the `*schema.Resource` defined in
    `hashicups/data_source_coffee.go`. Resources and data sources names must follow the `<provider>_<resource_name>`
    convention.

    Change your `DataSourcesMap` to contain our new data source.

    ```
      DataSourcesMap: map[string]*schema.Resource{
        "hashicups_coffees":     dataSourceCoffees(),
      },
    ```

    Format your code.

    ```
    go fmt ./...
    ```

    *Test the provider*

    Build the provider binary.

    ```
    cd /root/github.com/hashicorp/terraform-provider-hashicups
    make build
    ```

    Create the appropriate subdirectory within the user plugins directory for the HashiCups provider if it doesn't
    exist already.

    ```
    export OS_ARCH="$(go env GOHOSTOS)_$(go env GOHOSTARCH)"
    mkdir -p ~/.terraform.d/plugins/hashicorp.com/edu/hashicups/0.2/$OS_ARCH
    ```

    Next, move the binary to the appropriate subdirectory within your user plugins directory.

    ```
    mv terraform-provider-hashicups ~/.terraform.d/plugins/hashicorp.com/edu/hashicups/0.2/$OS_ARCH
    ```

    Navigate to the `terraform-provider-hashicups/examples` directory. This contains a sample Terraform configuration
    for the Terraform HashiCups provider.

    ```
    cd examples
    ```

    Finally, initialize your workspace to refresh your HashiCups provider, then apply. This should return the
    properties of "Packer Spice Latte" in your output.

    ```
    terraform init && terraform apply --auto-approve
    ```

    You should see output like the below.

    ```
    Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

    Outputs:

    psl = {
      "1" = {
        "description" = ""
        "id" = 1
        "image" = "/packer.png"
        "ingredients" = tolist([
          {
            "ingredient_id" = 1
          },
          {
            "ingredient_id" = 2
          },
          {
            "ingredient_id" = 4
          },
        ])
        "name" = "Packer Spiced Latte"
        "price" = 350
        "teaser" = "Packed with goodness to spice up your images"
      }
    }
    ```

    Congratulations! You created your first Terraform provider and data resource to reference information from an API
    in your Terraform configuration.
  notes:
  - type: text
    contents: |-
      In these tutorials, you will write a custom provider against the API of a fictional coffee-shop application
      called HashiCups using the Terraform Plugin SDKv2. Through the process, you will learn how to create data
      sources, authenticate the provider to the HashiCups client, and create resources with CRUD functionality.
  - type: text
    contents: |-
      - Set up your development environment.
      - Define the coffees data source.
      - Define the coffees schema.
      - Implement read.
      - Add coffees data source to the provider schema.
  tabs:
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/github.com/hashicorp/terraform-provider-hashicups
  - title: Terminal
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 900
- slug: add-authentication-to-a-provider
  id: tn3cgrhoyknp
  type: challenge
  title: Add Authentication to a Provider
  teaser: In this challenge you will learn to implement authentication in a Terraform
    Provider.
  assignment: |-
    *Update provider schema*

    HashiCups requires a username and password to generate an JSON web token (JWT) which is used to authenticate
    against protected endpoints. You will use this user to authenticate to the HashiCups provider to manage your
    orders.

    Create a user on HashiCups named `education` with the password `test123`.

    ```
    curl -X POST localhost:19090/signup -d '{"username":"education", "password":"test123"}' | jq
    ```

    You can then sign in again in the future using the below.

    ```
    curl -X POST localhost:19090/signin -d '{"username":"education", "password":"test123"}'
    ```

    Set a `HASHICUPS_TOKEN` environment variable to the token generated in the previous step. You will use this later
    tutorials to verify your HashiCups order has been created, updated and deleted.

    ```
    export HASHICUPS_TOKEN=<YOUR_TOKEN_HERE>
    ```

    In your `hashicups/provider.go` file, replace the `Provider()` function with the code snippet below. This defines
    the provider schema (`username`, `password`) and the `ConfigureContextFunc`.

    ```
    // Provider -
    func Provider() *schema.Provider {
      return &schema.Provider{
        Schema: map[string]*schema.Schema{
          "username": &schema.Schema{
            Type:        schema.TypeString,
            Optional:    true,
            DefaultFunc: schema.EnvDefaultFunc("HASHICUPS_USERNAME", nil),
          },
          "password": &schema.Schema{
            Type:        schema.TypeString,
            Optional:    true,
            Sensitive:   true,
            DefaultFunc: schema.EnvDefaultFunc("HASHICUPS_PASSWORD", nil),
          },
        },
        ResourcesMap: map[string]*schema.Resource{},
        DataSourcesMap: map[string]*schema.Resource{
          "hashicups_coffees":     dataSourceCoffees(),
        },
        ConfigureContextFunc: providerConfigure,
      }
    }
    ```

    Format your code.

    ```
    go fmt ./...
    ```

    Notice the `DefaultFunc` for both the `username` and `password` parameters attempts to use the respective
    environment variables as the default values. This is useful for automated provider testing.

    *Define `preconfigure`*

    Import the `context`, API client and `diag` libraries into the `provider.go` file. The `providerConfigure` function
    will use these libraries.

    ```
    import (
    + "context"

    + "github.com/hashicorp-demoapp/hashicups-client-go"
    + "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
      "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
    )
    ```

    Then, add the `providerConfigure` function below your `Provider()` function. This function retrieves the `username`
    and `password` from the provider schema to authenticate and configure your provider.

    ```
    func providerConfigure(ctx context.Context, d *schema.ResourceData) (interface{}, diag.Diagnostics) {
      username := d.Get("username").(string)
      password := d.Get("password").(string)

      // Warning or errors can be collected in a slice type
      var diags diag.Diagnostics

      if (username != "") && (password != "") {
        c, err := hashicups.NewClient(nil, &username, &password)
        if err != nil {
          return nil, diag.FromErr(err)
        }

        return c, diags
      }

      c, err := hashicups.NewClient(nil, nil, nil)
      if err != nil {
        return nil, diag.FromErr(err)
      }

      return c, diags
    }
    ```

    Format your code.

    ```
    go fmt ./...
    ```

    Notice that the function is able to retrieve the `username` and `password` values from the `*schema.ResourceData`.
    The HashiCups API client is a simple API wrapper for the HashiCups API.

    By returning the HashiCups API client, the provider will be able to access the API client as a `meta` input
    parameter. You will use the `meta` input parameter to access a protected endpoint (`/orders`) later in this track.

    Save your `hashicups/provider.go` file, then run `go mod vendor` to download the API client library into your
    `/vendor` directory.

    *Test the provider*

    Build the provider binary.

    ```
    cd /root/github.com/hashicorp/terraform-provider-hashicups
    make build
    ```

    Create the appropriate subdirectory within the user plugins directory for the HashiCups provider if it doesn't
    exist already.

    ```
    export OS_ARCH="$(go env GOHOSTOS)_$(go env GOHOSTARCH)"
    mkdir -p ~/.terraform.d/plugins/hashicorp.com/edu/hashicups/0.2/$OS_ARCH
    ```

    Next, move the binary to the appropriate subdirectory within your user plugins directory.

    ```
    mv terraform-provider-hashicups ~/.terraform.d/plugins/hashicorp.com/edu/hashicups/0.2/$OS_ARCH
    ```

    Navigate to the `terraform-provider-hashicups/examples` directory. This contains a sample Terraform configuration
    for the Terraform HashiCups provider.

    ```
    cd examples
    ```

    Then, authenticate your provider. You can either set them via environment variables (recommended) or update your
    provider block. Find an example using environment variables below.

    ```
    export HASHICUPS_USERNAME=education
    export HASHICUPS_PASSWORD=test123
    ```

    Finally, initialize your workspace to refresh your HashiCups provider, then apply.

    ```
    terraform init && terraform apply --auto-approve
    ```

    Check the terminal containing your HashiCups logs for the recorded operations invoked by the HashiCups provider.

    ```
    api_1  | 2020-12-10T09:26:23.349Z [INFO]  Handle User | signin
    api_1  | 2020-12-10T09:26:23.357Z [INFO]  Handle Coffee
    api_1  | 2020-12-10T09:26:23.488Z [INFO]  Handle User | signin
    api_1  | 2020-12-10T09:26:23.606Z [INFO]  Handle User | signin
    ```

    The provider should have invoked a request to the `signin `endpoint.

    Congratulations! You have added authentication to your HashiCups provider.
  notes:
  - type: text
    contents: In these tutorials, ...
  tabs:
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/github.com/hashicorp/terraform-provider-hashicups
  - title: Terminal
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 600
- slug: implement-a-complex-read
  id: eaos5eypeqtn
  type: challenge
  title: Implement a Complex Read
  teaser: In this challenge you will read from a auth protected endpoint.
  assignment: |-
    *Create an order via API*

    Before you can query a user's order, you must first create an order. Replace the authorization token with the token you generated in the sign in step.

    ```
    curl -X POST -H "Authorization: ${HASHICUPS_TOKEN}" localhost:19090/orders -d '[{"coffee": { "id":1 }, "quantity":4}, {"coffee": { "id":3 }, "quantity":3}]'curl -X POST -H "Authorization: ${HASHICUPS_TOKEN}" localhost:19090/orders -d '[{"coffee": { "id":1 }, "quantity":4}, {"coffee": { "id":3 }, "quantity":3}]'
    ```

    Query the order using the order ID you received in the response above as a HTML parameter (localhost:19090/orders/{orderID}). The response should be the same as the response above.

    ```
    curl -X GET -H "Authorization: ${HASHICUPS_TOKEN}" localhost:19090/orders/1
    ```

    *Define order data resource*

    Now, create a file named hashicups/data_source_order.go in your hashicups directory and add the following snippet.

    ```
    package hashicups

    import (
      "context"
      "strconv"

      hc "github.com/hashicorp-demoapp/hashicups-client-go"
      "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
      "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
    )

    func dataSourceOrder() *schema.Resource {
      return &schema.Resource{
        ReadContext: dataSourceOrderRead,
        Schema: map[string]*schema.Schema{
          "id": &schema.Schema{
            Type:     schema.TypeInt,
            Required: true,
          },
          "items": &schema.Schema{
            Type:     schema.TypeList,
            Computed: true,
            Elem: &schema.Resource{
              Schema: map[string]*schema.Schema{
                "coffee_id": &schema.Schema{
                  Type:     schema.TypeInt,
                  Computed: true,
                },
                "coffee_name": &schema.Schema{
                  Type:     schema.TypeString,
                  Computed: true,
                },
                "coffee_teaser": &schema.Schema{
                  Type:     schema.TypeString,
                  Computed: true,
                },
                "coffee_description": &schema.Schema{
                  Type:     schema.TypeString,
                  Computed: true,
                },
                "coffee_price": &schema.Schema{
                  Type:     schema.TypeInt,
                  Computed: true,
                },
                "coffee_image": &schema.Schema{
                  Type:     schema.TypeString,
                  Computed: true,
                },
                "quantity": &schema.Schema{
                  Type:     schema.TypeInt,
                  Computed: true,
                },
              },
            },
          },
        },
      }
    }
    ```

    Format your code.

    ```
    go fmt ./...
    ```

    Notice how the schema mirrors the JSON response — only id and items exist on the top level.

      - The id is required because an order ID must be set so the data source knows which order to retrieve.
      - The items schema is a computed list (schema.TypeList) of objects (schema.Resource) containing coffee attributes and quantity.
      - The coffee attributes is flattened and mapped accordingly (coffee.id is mapped to coffee_id, etc...)

    You will learn an alternative method to nest maps in the Implement Create tutorial, when you create new orders.

    *Implement complex read*

    Now that you have defined  the order schema, add the dataSourceOrderRead function to hashicups/data_source_order.go. This function will retrieve the order and map its values to the order schema defined above.

    ```
    func dataSourceOrderRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
      c := m.(*hc.Client)

      // Warning or errors can be collected in a slice type
      var diags diag.Diagnostics

      orderID := strconv.Itoa(d.Get("id").(int))

      order, err := c.GetOrder(orderID)
      if err != nil {
        return diag.FromErr(err)
      }

      orderItems := flattenOrderItemsData(&order.Items)
      if err := d.Set("items", orderItems); err != nil {
        return diag.FromErr(err)
      }

      d.SetId(orderID)

      return diags
    }
    ```

    Format your code.

    ```
    go fmt ./...
    ```

    Notice the m (meta) input parameter contains the HashiCups API Client set by the ConfigureContextFunc defined above. If provider uses an unauthenticated API Client, this function will fail and return an error message.

    The API Client's GetOrder function returns an order object. However, you must flatten this response to accurately map the response to the order schema. An order consists of an order ID and a list of coffee objects and their respective quantities. As a result, the order object must go through one flattening function to populate the list of coffee objects and their quantities.

    Add the flattenOrderItemsData function to your hashicups/data_source_order.go file. This returns a list of order items.

    ```
    func flattenOrderItemsData(orderItems *[]hc.OrderItem) []interface{} {
      if orderItems != nil {
        ois := make([]interface{}, len(*orderItems), len(*orderItems))

        for i, orderItem := range *orderItems {
          oi := make(map[string]interface{})

          oi["coffee_id"] = orderItem.Coffee.ID
          oi["coffee_name"] = orderItem.Coffee.Name
          oi["coffee_teaser"] = orderItem.Coffee.Teaser
          oi["coffee_description"] = orderItem.Coffee.Description
          oi["coffee_price"] = orderItem.Coffee.Price
          oi["coffee_image"] = orderItem.Coffee.Image
          oi["quantity"] = orderItem.Quantity

          ois[i] = oi
        }

        return ois
      }

      return make([]interface{}, 0)
    }
    ```

    Format your code.

    ```
    go fmt ./...
    ```

    The flattenOrderItemsData function takes an *[]hc.OrderItem as orderItems. If orderItems is not nil, it will iterate through the slice and map its values into a map[string]interface{}. Notice how the function assigns the coffee attributes directly to its corresponding flattened attribute (orderItem.Coffee.ID -> coffee_id).

    *Add data source to provider*

    Now that you've defined the order data source, you can add it to your provider.

    In your hashicups/provider.go file, add the order data source to the DataSourcesMap of your Provider() function. Resources and data sources names must follow the <provider>_<resource_name> convention.

    ```
    // Provider -
    func Provider() *schema.Provider {
      return &schema.Provider{
        Schema: map[string]*schema.Schema{
          "username": &schema.Schema{
            Type:        schema.TypeString,
            Optional:    true,
            DefaultFunc: schema.EnvDefaultFunc("HASHICUPS_USERNAME", nil),
          },
          "password": &schema.Schema{
            Type:        schema.TypeString,
            Optional:    true,
            Sensitive:   true,
            DefaultFunc: schema.EnvDefaultFunc("HASHICUPS_PASSWORD", nil),
          },
        },
        ResourcesMap: map[string]*schema.Resource{},
        DataSourcesMap: map[string]*schema.Resource{
            "hashicups_coffees":     dataSourceCoffees(),
    +       "hashicups_order":       dataSourceOrder(),
        },
        ConfigureFunc: providerConfigure,
      }
    }
    ```

    *Test the provider*

    Build the provider binary.

    ```
    cd /root/github.com/hashicorp/terraform-provider-hashicups
    make build
    ```

    Create the appropriate subdirectory within the user plugins directory for the HashiCups provider if it doesn't
    exist already.

    ```
    export OS_ARCH="$(go env GOHOSTOS)_$(go env GOHOSTARCH)"
    mkdir -p ~/.terraform.d/plugins/hashicorp.com/edu/hashicups/0.2/$OS_ARCH
    ```

    Next, move the binary to the appropriate subdirectory within your user plugins directory.

    ```
    mv terraform-provider-hashicups ~/.terraform.d/plugins/hashicorp.com/edu/hashicups/0.2/$OS_ARCH
    ```

    Navigate to the `terraform-provider-hashicups/examples` directory. This contains a sample Terraform configuration
    for the Terraform HashiCups provider.

    ```
    cd examples
    ```

    Add the following Terraform configuration to main.tf.

    ```
    data "hashicups_order" "order" {
      id = 1
    }

    output "order" {
      value = data.hashicups_order.order
    }
    ```

    Finally, initialize your workspace to refresh your HashiCups provider, then apply. Notice how the coffee attributes are flattened.

    ```
    terraform init && terraform apply --auto-approve
    ```

    This should return the first order in your output.

    ```
    Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

    Outputs:

    order = {
      "id" = 1
      "items" = [
        {
          "coffee_description" = ""
          "coffee_id" = 1
          "coffee_image" = "/packer.png"
          "coffee_name" = "Packer Spiced Latte"
          "coffee_price" = 350
          "coffee_teaser" = "Packed with goodness to spice up your images"
          "quantity" = 4
        },
        {
          "coffee_description" = ""
          "coffee_id" = 3
          "coffee_image" = "/nomad.png"
          "coffee_name" = "Nomadicano"
          "coffee_price" = 150
          "coffee_teaser" = "Drink one today and you will want to schedule another"
          "quantity" = 3
        },
      ]
    }
    ```

    Congratulations! You have implemented a nested read function.
  notes:
  - type: text
    contents: 'In this tutorial, you will retrieve an order, a protected endpoint,
      to verify whether a Terraform provider that interacts with the API of a fictional
      coffee-shop application, HashiCups, has been authenticated to the API successfully.
      The order schema contains nested objects, making it a more complicated data
      structure than the previously defined coffee data source. To do this, you will:'
  - type: text
    contents: |-
      - Create a new order via API
      - Define order data source.
      - Define order schema.
      - Implement complex read.
      - Add order data source to the provider schema.
  tabs:
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/github.com/hashicorp/terraform-provider-hashicups
  - title: Terminal
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 600
checksum: "5736938974036304556"
